# ch7 주요 디자인 패턴

## 전략(Strategy) 패턴

- 반복적인 기능을 수행하는 경우 전략 패턴을 통해 코드를 확장 가능하도록 변경할 수 있다
- 여러 할인 정책을 구현하는 과정에서 첫 손님인 경우, 과일이 덜 신선한 시간대인 경우 등 여러가지 조건이 있을 수 있다
- 할인을 적용해 계산하는 부분에서 if-else 형태로 각 할인 조건에 따라 계산을 수행하게 되면, 새로운 조건이 추가되는 경우마다 코드를 수정해줘야 한다
<br>

- 이런 경우 인터페이스로 기본적인 할인전략을 추상화시킨 후 각 조건들은 이 인터페이스를 구현하는 구조로 변경한다
- 그리고 할인을 적용해 계산하는 부분에서는 인터페이스 타입을 사용하도록 작성하면 코드의 변경없이 여러 조건을 추가할 수 있다
- 즉, 개방 폐쇄 원칙을 따르는 구조를 갖게 된 것이다
- 또한 위 상황에서 클라이언트 부분에서 어떤 할인 조건을 사용할 지를 직접 계산하는 부분에 주입을 해주게 된다
- 인터페이스를 구현한 콘크리트 객체중 원하는 것을 주입해주는 흐름이다

<br>

## 템플릿 메서드(Template Method) 패턴

- 구현의 일부가 다르고 데이터를 처리하는 과정이 동일한 경우
- 상위 클래스를 정의하고 동일했던 실행 과정을 메서드로 구현 -> 모든 하위 타입에 동일하게 적용되는 메서드 = 템플리 메서드
- 일반적인 경우 하위 타입이 상위 타입의 기능을 재사용할지 여부를 결정하지만, 템플릿 메서드 패턴에서는 상위 타입의 템플릿 메서드가 모든 실행 흐름을 제어한다
- 하위 타입의 메서드는 템플릿 메서드에서 호출되는 구조를 가진다
- 템플릿 메서드에서 호출하는 메서드를 추상 메서드로 정의하여, 하위 타입에서 이를 알맞게 재정의하도록 구현할 수 있다

<br>

## 템플릿 메서드와 전략 패턴의 조합

- 상속에 기반을 둔 템플릿 메서드를 사용
- 상속의 경우 클래스가 불필요하게 증가할 수 있고, 런타임에 교체할 수 없는 단점이 있는 반면에 조립/위임을 사용하는 경우에는 런타임에
탬플릿 메서드에 사용할 객체를 교체할 수 있는 장점을 갖게 된다
- 반대로, 상속의 경우 메서드를 재정의하는 방법으로 하위 클래스에서 쉽게 확장 기능을 제공할 수 있지만, 조립/위임 방식에서는 확장 기능을 제공하려면
구현이 다소 복잡해지는 단점이 있다

***

<br>

## 상태(State) 패턴

- 기본 상태가 되는 부분을 인터페이스로 구현
- 상태패턴에서 컨텍스트의 상태 변경을 어디거 할지를 크게 두 가지로 나눌 수 있다
- 컨텍스트에서 변경하기, 상태 객체에서 변경하기
- 컨텍스트에서 상태변경 시 상태 종류가 지속으로 변경되거나 변경 규칙이 자주 바뀔 경우 복잡해질 수 있지만, 상태 객체에서 변경하는 경우는
여러 클래스에 분산되게 되어 컨텍스트에서 변경하는 방식이 그래도 더 구조를 파악하는데는 유리하다고 생각한다


***
<br>
