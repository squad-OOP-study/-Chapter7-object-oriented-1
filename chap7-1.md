# chapt7 디자인패턴-01 

2022.3.6

## 목차

1. 전략 패턴
2. 템플릿 패턴
3. 상태 패턴
4. 데코레이터 패턴

___

## 느낀점

- 상태 패턴과 전략 패턴
  - 상태 패턴의 VendingMachine 예시를 보면서 설계 관점을 자판기를 사용하는 사람에게 두느냐 , 자판기에 두느냐에 따라 설계가 이렇게 상태패턴으로도 될 수 있겠구나라는 생각이 들었다.
    - 처음에는 자판기 사용자 관점에서 설계 했을 것 같다. 그러면 자연스럽게 설계 자체가 전략패턴이 되었을 것 같다.
    - 자판기 관점에서 상태패턴을 사용한다면 여러가지 상황들이 하나의 상태로 관리되면서 생각이나 설계가 복잡하지 않게 정리될 수 있겠구나 생각이 들었다.
- 템플릿 메서드 
  - 템플릿 메서드를 공부하면서 추상클래스와 인터페이스의 차이를 느낄 수 있었다.
  - 추상클래스는 흐름 제어를 추상클래스 자체가 가져갈 수 있는 구조로 설계할 수 있는 형태이고,
  - 인터페이스는 흐름 제어를 인터페이스를 사용하는 곳에서 제어할 수 있는 형태라 생각이든다.
  - 나중에 SSO인증처리할 때 네이버/카카오/구글 등의 여러 케이스를 추상클래스와 함께 템플릿 메서드로 구현해보고 싶다. 
- 데코레이터 패턴
  - 데코레이터 패턴을 UML로 설명하는 책의 예제는 FileIO부분이라서 와닿지 않았었다.
  - 그런데  게시글 작성 이후 외부 메세지 서버에 수신하는 부분은 데코레이터 패턴이 어디에 사용될지 예상하는데 훨씬 도움이 됐다.
  - 데코레이터 패턴은 **기본 기능에 추가 기능을 얻힐 때 사용하는 패턴이다** 라는 히데의 말 또한 데코레이터 패턴을 언제 사용해볼지 생각할 수 있는 말이였다.
  - 기본 기능과 추가 기능을 분리해 생각하면 실패 시 처리 방법을 더 확실히 생각해볼 수 있을 것 같다.
  
<br><br>
___

## 내용정리 

<br><br>

> 디자인패턴이란
- 반복적으로 사용되는 클래스/객체의 구성, 객체 간 메세지 흐름의 일정 패턴
- GoF의 디자인패턴은 객체의 생성, 기능의 확장, 기능의 변경, 구조등과 관련된 20여 개의 패턴 정리 

<br><br>

# 전략패턴 

- 정책이 추가 될 때 정책을 별도 객체로 분리 
- 변화되는 부분을 추상화하여 각 콘크리트 클래스는 상황에 맞는 알고리즘을 제공
- **특정 context(콘텍스트)에서 알고리즘을 별도로 분리하는 설계 방법**
- 예시) 
  
|클래스|명명  |설명|특징|
|------|-----|----|-----|
|Calculate|Context|가격 계산 기능 책임|사용할 전략 주입 받음|
|DiscountStrategy|Strategy|가격 할인 알고리즘 추상화||

- <img src ="https://user-images.githubusercontent.com/55780251/156905869-40f01531-f6de-46c1-b041-badd7b7320c9.jpg" width="60%">


> 특징
- context의 클라이언트가 context에 사용할 전략을 의존 주입(DI)을 통해서 전달한다.
- strategy가 어떤 메서드를 제공할지 여부는 context가 전략을 어떤 식으로 사용하느냐에 따라 달라진다.
- OCP 실현. 확장에는 열려있고, 변경에는 닫혀있는
- 전략 객체는 콘텍스트를 사용하는 클라이언트에서 직접 생성한다. 즉, 콘텍스트 사용 클라이언트가 전략 상세 구현에 대해 의존한다.    
 **해당 의존은 문제처럼 보일 수 있으나, 전략 콘크리트 클래스와 클라이언트의 코드가 쌍을 이루기 때문에 유지보수 문제가 발생할 가능성이 줄어든다.**

 <img src ="https://user-images.githubusercontent.com/55780251/156905870-f4872c86-324e-42ab-9d6a-553dc481eadb.jpg" width="60%">


> 전략패턴 사용할 곳

- if-else로 구성된 코드 블록이 비슷한 기능을 수행하는 경우 
- 완전히 동일한 기능을 제공하지만 성능의 장단점에 따라 알고리즘을 선택해야 하는 경우 

<br><br>

# 템플릿 메서드

- 실행과정/단계는 동일한데 각 단계 중 일부의 구현이 다른 경우에 사용할 수 있는 패턴
- 동일한 절차를 가지면서 일부 과정의 구현만 다를 때 사용 
- 예시)
  - 인증처리 절차는 동일하나, 사용자 정보를 가져오는 부분의 구현만 DB데이터 또는 LDAP을 이용해서 다른 경우.

> 구성 
1. 실행 과정을 구현한 상위클래스
2.  실행 과정의 일부 단계를 구현한 하위 클래스 

- 상위에서 흐름을 가져가야 하기 때문에 추상클래스를 상속하는 상속에 기반한 패턴이다.
  - 하위클래스에서 구현할 실행과정의 일부는 protected로 구성해 상위클래스에서 흐름 제어를 하면서 구현이 다른 부분을 처리할 수 있게 한다.
- 상위클래스에서 모든 하위타입에 동일하게 적용되는 실행 과정을 제공하는 메서드를 '템플릿 메서드' 라고 한다.
- 훅(hook) 메서드 : 하위 클래스에서 알맞게 확장할 수 있는 메서드

> 특징
- 보통은 하위 타입이 상위 타입의 기능 재사용 여부를 결정하기 때문에 흐름 제어를 하위타입이 하게 된다.
- 템플릿 메서드는 상위 타입의 템플릿 메서드가 흐름을 제어하고, 템플릿 메서드에서 하위 타입의 메서드를 호출하는 구조를 갖는다. 

> 템플릿 메서드 + 전략 패턴
- 템플릿 메서드 패턴의 변형 
- 상속이 아닌 조립 방식으로 템플릿 메서드 패턴 활용 
- 차이점
  - 일반 템플릿 메서드 : 템플릿 메서드가 상속받은 하위 타입의 메서드를 호출한다.
  - 혼합 템플릿 메서드 : 템플릿 메서드가 파라미터로 전달받은 객체의 메서드를 호출한다. 
- 상속에 기반한 템플릿 메서드에 비해  런타임등에 사용할 객체 교체등 유연함을 갖는다. 
- 조립/위임 방식에서는 확장 기능을 제공하려면 구현이 다소 복잡해진다.

<br><br>

# 상태 패턴

- 상태에 따라 동일한 기능 요청 처리를 다르게 할 때 사용할 수 있는 패턴
- 상태를 별도 타입으로 분리
- 각 상태 별로 알맞은 하위 타입 구현
- <img src="https://user-images.githubusercontent.com/55780251/156905871-d2417f1e-907b-41aa-b8d3-b4f22988eac0.jpg" width="60%">

> 특징
- 상태 객체가 기능을 제공한다는 점
- 콘텍스트는 필드로 상태 객체를 갖고 있고, 클라이언트로부터 기능 실행 요청을 받으면 상태 객체 처리를 위임하는 방식으로 구현.

> 상태 변경은 누가?
- 상태 변경 주체는 콘텍스트 , 상태 객체 둘 중 하나. 
- 상태 변경 주체 : 상태 객체
  - 상태 객체에서 조건을 확인하기 위해 콘텍스트의 다른 값에 접근해야 할 때도 있다. 그러므로 콘텍스트 인터페이스에 조건 확인 메서드를 추가해야 한다.
  - 상태 객체에 제공해야 하는 메서드가 추가됨으로 콘텍스트의 코드가 다소 복잡해질 수 있다.
- 상태 변경 주체 : 콘텍스트
  - 상태 객체 코드가 자신이 수행해야 하는 작업만 처리하게 됨으로 코드가 깔끔
- 상태 변경 주체는 상황에 알맞게 정해야 한다.
  - 상태 개수가 적고 상태 변경 규칙이 거의 바뀌지 안흔 경우에는 콘텍스트에서 상태 변경하는 것이 유리
  - 콘텍스트에 영향을 주지 않으면서 상태를 추가하거나 상태 변경 규칙을 바꿀 경우. 
  - 단점은 상태 클래스가 많아질 수록 상태 변경 규칙을 파악하기 어렵고 다른 상태에 대한 의존이 발생하기도 한다.

<br><br>

# 데코레이터 패턴

- 상속을 이용한 기능 확장이 쉽지만, 다양한 조합의 기능확장이 요구 될 때 클래스가 불필요하게 증가된다. 
- 이런 경우 사용할 수 있는 패턴이 데코레이터 패턴.
  
> 특징
- 위임 방식으로 기능 확장
- <img src="https://user-images.githubusercontent.com/55780251/156905875-1fddfd0c-8a01-4249-8277-f1a322025208.jpg" width="60%">
- 기능 확장을 위해 Decorator라는 별도 추상클래스 생성
  - 모든 데코레이터를 위한 기반 기능 제공하는 추상 클래스
  - 생성자를 통해 전달받은 객체에 공통 기능 위임

> 고려할 점
- 데코레이터 대상 타입의 기능 개수가 많을 때는 데코레이터의 구현도 복잡해진다.
- 객체가 비정상적으로 동작할 때 처리 방법 고민
  - 예시) 게시글 작성 후 게시글 데이터를 외부 메시지 서버에 전송해 주는 기능을 별도의 데코레이터로 구현. 
  - 외부 서버에 전송만 실패했을 경우 익셉션을 발생시키는 것이 올바른 것인가 고민해봐야 한다. 
  - 왜냐면 클라이언트가 요구하는 기능인 게시글 등록 자체는 정상적으로 실행 
  - 익셉션 대신 실패 로그 남기는 방법 선택 할 수 있다. 
  - 추후 로그로 사후 처리 할 수 있다. 


___

> 새롭게 알게 된 용어
- context : 기능 실행 클래스






  





